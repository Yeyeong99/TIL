# 병사 관리
- 가장 간단하게 생각하는 경우: 다른 함수와 비교했을 때 updateTeam 함수는 O(n) (특정 팀에 있는 병사들의 점수를 모두 변화시켜야 함)
- 따라서 updateTeam 함수를 기준으로 이 함수의 시간 복잡도를 줄일 수 있는 방법을 생각해야함
- 그룹핑> 팀, 점수 별로 나눈다고 생각하고 >[Linked List](#병사)로 구현해야함
    - 팀을 바꾼다고 생각하면 단순히 연결된 부분을 바꾸면 되는 것
    - 배열로 한다치면 병사들의 점수를 하나 하나 바꿔줘야 함 > 이걸 줄이기 위해 팀 별로 그룹화, 팀 안에서도 점수로 그룹화
    - 하나의 팀에 대해 각 점수를 변화시킬 점수로 보내면 되는 것

### 병사관리 v2
### hire
- O(1)

### fire
- O(n): 모든 병사를 순회해 찾을 경우
- position[mID]를 찍었을 때 팀과 점수를 반환하게 > 이런 경우 팀, 점수를 찾음. 찾은 후의 데이터는 linked list로 관리하고 있기 때문에 각 노드의 주소를 알 수 있음
- 위의 경우 팀과 점수를 반환하지 않고 노드의 주소를 반환한 후 그 주소를 이용해 삭제하게끔 할 수 있음
- 팀과 점수로 구분된 이중 linked list를 활용한다.
- 이런 경우 O(1)

### UpdateSoldier
- position[mid] 팀의 노드를 찾을 수 있음
- linked list 내부의 노드를 찾음(a) > a 이전의 노드의 주소를 a 이후로 옮김
- 옮겨야 하는 점수로 옮김
- O(n)

### BestSoldier
- n만큼 탐색해서 그 중 최댓값을 찾아도 됨.
- 100자리이기 때문 O(n)이어도 문제될 게 없다

### 수도 코드
- Group[팀][점수]: 이중 연결 리스트
- position[mID]: 호출하면 node의 주소 반환
- hire: 팀과 점수를 통해 그룹의 시작점(이중 연결 리스트의 - 시작점 헤드), head에 node 생성 후 연결
    - position[mID]에다가 생성한 node의 주소를 저장해줘야 함
- fire: mID를 기준으로 node 찾기, pre <> next로 하고 node를 free, position[mID]에서도 삭제
- updateSoldier: 점수 더할 때랑 뺄 때랑 순회 방식이 다름


> 글로 적어두면 디버깅 하는 데에도 도움이 된다!
> ### 최적화 시
> 1. 추가 자료 구조를 고려해볼 것
> 2. 안되면 메인 자료구조를 교체
> 참고: Lazy evaluations
> ### 알아둬야 함
> DFS BFS LCA(least common anchor - 최소 공통 조상 찾기)