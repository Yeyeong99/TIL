# 선형 Queue

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  - 뒤에서만 샆입, 앞에서만 삭제
  - FIFO: First in First out
  - enqueue, dequeue

## Queue 연산

|     종류      | 기능                            | 참고                                                         |
| :-----------: | :------------------------------ | :----------------------------------------------------------- |
| enqueue(item) | 아이템 삽입                     |
|   dequeue()   | 아이템 반환 및 삭제             | front : 마지막으로 삭제된 아이템 가리킴<br>rear: 현재 아이템 |
|  createQueue  | 큐 생성                         |
|   isEmpty()   | 큐가 비어있는지                 | front 와 rear가 만날 경우                                    |
|   isFull()    | 큐가 다 차있는지                |
|    Qpeek()    | 제일 앞의 원소를 삭제 없이 반환 |

### 선형 큐

- 1 차원 배열을 이용함
- 큐의 크기 = 배열의 크기
- front: 저장된 첫 번째 원소의 인덱스
- rear: 저장된 마지막 원소의 인덱스

### 상태 표현

- 초기 상태: front = rear = -1
- 공백 상태: front == rear
- 포화 상태: rear == n - 1(n 배열의 크기, n - 1은 배열의 마지막 인덱스)

## Queue 실습

### enqueue

```python
queue = [0] * 3
front = rear = -1
# 1, 2, 3
rear += 1   #enqueue 1
queue[rear] = 1

rear += 1   #enqueue 2
queue[rear] = 2

rear += 1   #enqueue 3
queue[rear] = 3
```

|       | front |     |     | rear |
| :---: | :---: | :-: | :-: | :--: |
| queue |       |  1  |  2  |  3   |
| index |  -1   |  0  |  1  |  2   |

### enqueue

```python
while front != rear:
    front += 1
    print(queue[front]) #1
```

|       |     | front |     | rear |
| :---: | :-: | :---: | :-: | :--: |
| queue |     |   1   |  2  |  3   |
| index | -1  |   0   |  1  |  2   |

## 선형 큐의 문제: 잘못된 포화상태 인식

- 선형 큐를 이용해 원소의 삽입과 삭제를 계속할 경우 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear = n - 1인 상태, 즉 포화 상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨
  | | | | front | rear |
  | :---: | :-: | :---: | :-: | :--: |
  | queue | | 1 | 2 | 3 |
  | index | -1 | 0 | 1 | 2 |
  <포화상태로 잘못 인식>

### 해결 방법 1

- 매 연산이 이뤄질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동 시킴
- 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 하락

### 해결 방법 2

- 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용

### 해결 방법 3

- front = rear = 0
- Index의 순환
  - front와 rear의 위치가 배열의 마지막 인덱스인 n - 1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
  - 이를 위해 나머지 연산자 mod 이용

# 원형 큐 (해결 방법 3)

## front 변수

- 공백 상태와 포화 상태 구분을 쉽게 하기 위해 [**front가 있는 자리는 사용하지 않고 항상 빈자리로**]()

- 삽입 위치 및 삭제 위치

  |        | 삽입                  | 삭제                    |
  | :----- | :-------------------- | :---------------------- |
  | 선형큐 | rear = rear + 1       | front = front + 1       |
  | 원형큐 | rear = (rear + 1) % n | front = (front + 1) % n |

## 공백 상태 / 포화 상태 확인

- 공백 상태: front == rear
- 포화 상태: 삽입할 rear의 다음 위치 == 현재 front
  - (rear + 1) % n == front

# 연결 큐

## 단순 연결 리스트를 이용한 큐

- 큐의 원소: 단순 연결 리스트의 노드
- 큐의 원소 순서: 노드의 연결 순서. 링크로 연결됨
- front: 첫 번째 노드를 가리키는 링크
- rear: 마지막 노드를 가리키는 링크

### 상태 표현

- 초기 상태: front = rear = null
- 공백 상태: front = rear = null

| front  |        |     |        |        |     |        |        |     |  rear  |      |
| :----: | :----: | :-: | :----: | :----: | :-: | :----: | :----: | :-: | :----: | :--: |
| 0x1000 |        |     | 0x1008 |        |     | 0x1010 |        |     | 0x1018 |      |
|   A    | 0x1008 | ➡️  |   B    | 0x1010 | ➡️  |   C    | 0x1018 | ➡️  |   D    | NULL |

- A 삽입
  |front, rear||
  |:-:|:-:|
  | 0x1000 ||
  |A|NULL|
- B 삽입
  |front|||rear||
  |:-:|:-:|:-:|:-:|:-:|
  | 0x1000 |||0x1008 |
  |A|0x1008|➡️|B|NULL

# Deque(덱)
- 컨테이너 자료형 중 하나
- deque 객체: 양쪽 끝에서 빠르게 추가, 삭제 가능. 리스트류 컨테이너
- append(x): 오른쪽에 x 추가
- popleft(): 왼쪽에서 요소를 제거 후 반환. 요소가 없으면 IndexError
    ```python
    from collections import deque

    q = deque()
    q.append(1)  # enqueue()
    t = q.popleft()  # dequeue()
    ```

# 우선순위 큐
## 우선순위 큐의 특성
- 우선순위를 가진 항목을 저장하는 큐
- FIFO 순서가 아닌 우선 순위가 높은 순서대로 먼저 나감

## 적용 분야
- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영체제의 테스크 스케줄링링

## 문제
- 배열을 사용할 때 삽입, 삭제의 연산 중 원소의 재배치가 필요. 여기서 소요되는 시간, 메모리 낭비가 크다.

# 버퍼
- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼링: 버퍼를 활용하는 방식 or 버퍼를 채우는 동작을 의미함

## 버퍼의 자료구조
- 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용됨
- 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐를 활용함함