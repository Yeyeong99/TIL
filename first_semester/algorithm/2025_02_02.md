# 개념 정리

## 알고리즘 기본

### 알고리즘

1. 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
2. 어떠한 문제를 해결하기 위한 절차
3. 표현 방법: 의사코드, 순서도, 프로그래밍 언어

   > 의사코드 작성시: 불필요한 내용은 제거, 명확성을 높이는 방법으로 작성하기

4. 좋은 알고리즘의 요건

   - 정확성
   - 효율성: 얼마나 최적화되었나
   - 확장성: 입력 크기에 상관없이 항상 성능이 일정한가
   - 단순성

   > 확장성, 정확성 > 효율성 > 단순성 순으로 고려하기

5. 성능 분석: 연산의 총합을 비교

### 복잡도

1. 시간복잡도: 연산의 작업량, 수행 시간
   |이름|구분|설명|
   |:-:|:-:|:-:|
   |빅 오메가 표현법|최선의 경우|알고리즘이 가장 빠르게 실행될 경우의 성능|
   |빅 세타 표기법|평균|일반적인 알고리즘의 기능|
   |빅 오 표기법|최악|알고리즘이 가장 느리게 실행될 때의 성능|

2. 공간복잡도: 메모리의 사용량
3. 빅-오 표기법
   > 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표기하기 위해 점근적 표기법을 사용.
   > <br><br>
   > n이 가장 큰 영향력을 주기 때문에 n에 대한 항만을 표시. 따라서 계수는 생략하여 표시
   - log의 밑은 2다.

## 재귀

### 재귀 vs 반복

1. 반복과 재귀는 유사한 작업을 수행 가능
2. 반복은 수행하는 작업이 완료될 때까지 반복
3. 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

### 재귀 함수(recursive function)

1. 함수 내부에서 직접 / 간접적으로 자기 자신을 호출하는 함수
2. 기본 부분 basis part, 유도 부분 inductive part로 구성
3. 반복문에 비해 간결하고 이해가 쉽다
4. 함수 호출은 프로그램 메모리 구조에서 스택을 사용함
5. 예시) 팩토리얼, 피보나치 수열 계산, **하노이의 탑**

## 완전 탐색
> 하노이의 탑에서 n = 3인 경우만 생각하고 문제를 풀 경우, n의 값이 커지면 바로 적용이 안되는 상황이 생길 수 있다. 이러한 문제를 해결하고, 코드의 정확성, 확장성을 위해서는 완전탐색적 사고를 할 필요가 있다.

> 모든 경우의 수를 생성하고 테스트하기 때문에 속도는 느림. 하지만 해답을 찾을 확률은 높음

### Brute-force
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열하고 확인해보는 기법
- 대부분의 문제에 적용 가능
- 상대적으로 빠른 시간 안에 문제 해결 가능
일반적으로 경우의 수가 작으면 유용
- 전형적으로 permutation, combination, subset과 같은 조합적 문제와 연관됨
- 검정 등의 상황에선 **완전 검색으로 접근해 해답을 도출한 후 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함**

### 순열 Permutation
- for 문: n > 12 인 경우 시간이 폭발적으로 증가
- 재귀 함수 형태로 생성
    ```python
    def perm(selected, remain):
        if not remain:
            print(selected)
        else:
            for i in range(len(remain)):
                select_i = remain[i]
                # remain.pop(i) => pop(i)의 연산 횟수는 O(N)
                #O(1) 연산: 삭제된 요소 빼고, 나머지를 새로운 리스트로 초기화
                remain_list = remain[:i] + remain[i + 1:]
                perm(seleted + [select_i], remain_list)
    
    perm([], [1, 2, 3, 4, 5])
    ```
    - selected엔 빈 배열을, remain에 순열을 만들길 원하는 배열을 넘겨줌
    - for문을 이용할 때와 달리 배열의 입력이 달라져도 상관 없음

### 조합 Combination
- 재귀 함수 형태로 생성
    ```python
    def comb(arr, r):
        result = []
        # basis part
        # r -> 1개가 될 때까지
        if r == 1:
            return [[i] for i in arr]
    
        for i in range(len(arr)):
            select_i = arr[i]
            # 현재 요소 이후 나머지 요소들로 r-1 개의 조합을 생성
            for rest in comb(arr[i + 1:], r - 1):
                # 현재 선택한 요소 + 재귀호출해서 얻은 조합
                result.append([select_i] + rest)
        return result
    ```
    

### 순열과 조합의 활용
- Itertools 활용
- 중복 순열

### 부분 집합
- 이진수 형식으로 카운팅하는 것이 적합함
    |연산자|기능|예|
    |:-:|:-:|:-:|
    |&|비트열을 기준으로 양쪽 다 1일 때만 True 반환||
    |<<|value를 n 비트만큼 왼쪽으로 shift|1 << 1의 결과는 2진수 10 <br> 10 << 1의 경우 10의 2진수가 1010 이 전체가 한 칸씩 움직이니 10100| 
    |>>|value를 n 비트만큼 오른쪽으로 shift||
