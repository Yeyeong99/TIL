# 비트

## 비트 & 바이트

- 1 비트: 1과 0으로 표현되는 한 자리
- 1 바이트: 8 비트

## AND OR

- and(&): 둘 다 1일 때
- or(|): 하나라도 0일 때

```python
print(7 & 5)  # 5
print(7 | 5)  # 7
```

1. 이진수로 변환
2. 각 자리를 AND, OR 연산

> ##
>
> ### 참고>
>
> - `bin`, `hex` 함수 활용하기
> - `int` 함수 활용
>   ```python
>   print(int('1011', 2))  # 2 진수 / 11
>   print(int('b', 16))  # 16 진수 / 11
>   ```

### 예시

- 0b11011110 & 0b11011 계산하기

  | 첫 번째 숫자 | 1     | 1     | 0     | 1   | 1   | 1   | 1   | 0   |
  | ------------ | ----- | ----- | ----- | --- | --- | --- | --- | --- |
  | 두 번째 숫자 | [0]() | [0]() | [0]() | 1   | 1   | 0   | 1   | 1   |
  | 결과         | 0     | 0     | 0     | 1   | 1   | 0   | 1   | 0   |

  - [0]() : 자리는 뒤에서부터 맞추고 앞의 빈자리는 0으로 대체체

## XOR

- XOR(^): 같으면 0 다르면 1

- 특징
  ```python
  7070 ^ 1004 = 6,258
  6258 ^ 1004 = 7070
  ```
  - 어떤 값이든 특정 수로 2회 XOR을 하면 원래 수로 되돌아 옴
  - 암호화에 활용 가능

## Left Shift & Right Shift
- left shift <<: 특정 수 만큼 비트를 왼쪽으로 밀어냄
- right shift >>: 특정 수 만큼 비트를 오른쪽으로 밀어냄 (우측 비트가 제거 됨)
- 예시
  ```python
  print(bin(0b1101) << 2) # 0b110100
  print(bin(0b1101) >> 2) # 0b11
  ```
- 응용
  - 1 << n: 2 \*\* n의 값을 갖는다.
    - 임베디드 분야에서 빠른 계산을 위해 활용

### 부분 집합의 수를 바로 구할 수 있음

- 집합을 만들 때 각 숫자를 쓰거나 안쓰거나 => 0, 1로 생각하기
  ```python
  arr = [1, 2, 3, 4]
  print(1 << len(arr)) # 부분 집합의 수
  ```
- i & (1 << n): i의 n번째 비트가 1인지 아닌지 확인 가능
  ```python
  for i in range(1 << len(arr)):
      for idx in range(len(arr)):
          # (1 << idx): 0b1, 0b10, 0b100, 0b1000의 경우를 만들 수 있음
          if i & (1 << idx):
              # i 번째 부분 집합에 idx 요소가 포함되어 있는지 확인 가능
              # i의 idx 번째 bit가 1인지 확인 = 부분 집합에 포함되는지
              print(arr[idx], end=' ')
          print()
  ```
  ```python
  # 결과
    # 공집합
  1
  2
  1 2
  3
  1 3
  2 3
  1 2 3
  4
  1 4
  2 4
  1 2 4
  3 4
  1 3 4
  2 3 4
  1 2 3 4
  ```
  - idx 번째 비트가 1이면: arr[idx] 출력
  - i = 1일 때
    - idx 0이면
      - 1 << idx: 1
        - `if 1` -> arr[1] 출력
    - idx 1이면
      - 1 << idx: 2
        - `if 0` -> if 문 수행 안함

> 재귀와 반복문을 비교했을 때, 연산 횟수가 동일하다면 반복문이 당연히 효율적. 재귀는 스택에 쌓고 삭제하는 과정이 연산 중 포함되고, 재귀 호출 횟수도 제한 되기 때문

## 음수 표현 방법
- 2의 보수로 관리
    - 맨 앞자리 비트(MSB)는 음수 or 양수를 구분하는 비트
- 이유: 뺄셈의 연산 속도를 높일 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용함
### 예시
- 10001의 2의 보수
    - 각 자리를 모두 뒤집고 +1
    - 01110 + 1 = 01111
### 특성
- 2의 보수를 취한 수를 다시 2의 보수를 취할 경우 원래 값으로 돌아옴

## bitwise NOT(complement) 연산자
- 모든 비트를 반전시킴
- 파이썬에서는 ~4를 수행하면 -5가 출력 됨
    - 4 = 0b[0]()100 ([0](): 양수이므로 MSB가 [0]())
    - NOT 연산자로 뒤집으면 1011
        - 음수가 되었으므로 MSB는 1, 나머지 비트는 011
    - 나머지 비트에 대해 2의 보수를 취하면 100 + 1 = 101이므로 5가 됨
    - 따라서 -5

# 실수
## 소수점 출력 방법
```python
num = 2.1827
print(f"{num:.2f}") # 2.18
```
- num 값을 소수점 셋째 자리에서 반올림 해서 표현

## 실수 표현 범위
- 다른 언어와 달리 내부적으로 더 큰 규모의 자료구조를 사용하기 때문에 더 넓은 범위의 실수를 표현함
- 최대로 표현 가능한 값은 약 1.8 * (10 ** 308), 이 이상은 `inf`로 표현
- 최소로 표현 가능한 값은 약 5.0 * (10 ** (-324))