# 고지식한 알고리즘 (Brute Force)

- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

```python
# text, pattern을 인자로 받음
# text 속에서 pattern 찾기, 한 번 찾으면 중단단
def bruteforce(t, p):
    N = len(t)
    M = len(p)
    i = j = 0

    while i < N and j < M:
        if t[i] != p[j]: # 다르면
            i = i - j + 1 # i - j 비교를 시작한 위치에서 다음으로
            j = 0
        else:
            i += 1
            j += 1

    if j == M:
        return i - j # 패턴의 시작 인덱스
    else:
        return -1 # 패턴이 없는 경우


# text 속에서 pattern이 몇 번 등장하는지
def bruteforce(t, p):
    N = len(t)
    M = len(p)
    i = j = 0
    cnt = 0
    while i < N:
        if t[i] != p[j]: # 다르면
            i = i - j + 1 # i - j 비교를 시작한 위치에서 다음으로
            j = 0
        else:
            i += 1
            j += 1

        if j == M: #
            cnt += 1
            i = i - j + 1
            j = 0

```

### 시간 복잡도

텍스트의 모든 위치에서 패턴을 비교해야 하므로 [$O(MN)$]()이 됨

# KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대해 다시 비교하지 않고 매칭을 수행

### 시간 복잡도

- 텍스트의 모든 위치에서 패턴을 비교해야 하므로 [$O(M + N)$]()이 됨

### 예시

|  .  |  .  |  .  |  .  |  .  |  a  |  b  |  c  |  d  |  a  |  b  |  c  |  d  |  .  |  .  |  .  |  .  | .   |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | --- |
|     |     |     |     |     |  a  |  b  |  c  |  d  |  a  |  b  |  c  |  e  |  f  |
|     |     |     |     |     |     |     |     |     |  a  |  b  |  c  |  d  |  a  |  b  |  c  |  e  | f   |

- 한 칸만 이동하는 것이 아니라 일치한 부분까지는 저장, 그 바로 뒤로 이동
- 매칭이 실패했을 때 돌아갈 곳을 계산해 저장해야함

## 보이어 무어 알고리즘

- KMP와 비슷
- 패턴의 끝에서 앞으로 이동하며 비교
  - 대부분의 상용 소프트웨어에서 채택하고 있음
  - 끝에서 불일치 하면 바로 다음으로 넘어감
    - 넘어가는 정도: 패턴에서 주어진 텍스트와 일치하는 문자를 찾아서 둘을 맞춰 이동

### 참고

> for - else 활용: for 문 내에 있는 break에 걸리지 않고 for이 완료되었을 경우 else를 수행함
