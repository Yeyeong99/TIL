# OOP

## 절차 지향 프로그램

- 변수와 함수를 별개로 다룸
  
      1. 입력을 받기, 처리, 결과를 내는 과정이 위에서 아래로 순차적으로 흐르는 형태
  
      2. 순차적인 명령어 실행
  
      3. 데이터와 함수(절차)의 분리
  
      4. 함수 호출의 흐름이 중요

  > 데이터를 재사용하기보다는 처음부터 끝까지 개별의 함수가 수행되는 결과물이 중요함

- 한계
  1. 복잡성 증가
     - 규모가 커질수록 데이터, 함수 관리가 어려움
     - 전역변수 증가
  2. 유지보수 문제
     - 코드 수정 시 어디까지 영향을 미칠지 파악하는 것이 어려움

## 객체 지향 프로그래밍

- 절차 지향의 한계를 보완할 수 있는 패러다임
  - 기존 절차 지향을 기반으로 둠. 보완을 위해 객체라는 개념을 도입해 상속, 재사용성, 유지보수성의 이점을 갖게되는 것
- 객체 안에 관련한 기능이 포함됨
  1. 프로그램을 데이터와 해당 데이터를 처리하는 함수를 하나의 단위, 객체로 묶어 조직적으로 관리
  2. 데이터와 매서드의 결합
  3. 데이터가 능동적인 객체로 변함

|                     절차 지향                     |                          객체지향                           |
| :-----------------------------------------------: | :---------------------------------------------------------: |
| 데이터와 해당 데이터를 처리하는 함수(절차)가 분리 | 데이터와 해당 데이터를 처리하는 메서드를 하나의 객체로 묶음 |
|              함수 호출의 흐름이 중요              |            객체 간 상호작용, 메시지 전달이 중요             |

## 객체와 클래스

|                                                        객체                                                         |                                                클래스                                                 |
| :-----------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------: |
| 실제 존재하는 사물을 추상화한 것<br>속성(객체의 상태/데이터)과 동작(메서드)<br>각 객체는 고유한 특성을 가짐(고유성) | 객체를 만들기 위한 설계도<br>데이터와 기능을 함께 묶는 방법을 제공<br>파이썬에서 타입을 표현하는 방법 |

### 클래스

1. 파스칼 케이스 사용(cf snake case)

2. `__init__` : 생성자 메서드

   - 새로운 객체를 만들 때 필요한 초기값을 설정
   - 인스턴스 변수의 초기화 담당

3. 인스턴스: 클래스로 만든 개별 객체, 특정 클래스의 인스턴스라고 표현하는 것이 가장 정확함

4. 인스턴스 변수(속성)

   - 각 인스턴스 별 고유한 속성
   - self.변수명 형태로 정의
   - 인스턴스마다 독립적인 값 유지

5. 클래스 변수
   - 인스턴스가 모두 공유 가능
   - 클래스 내부에서 직접 정의

## 메서드

### self 동작 원리

```python
'hello'.upper() # 1
str.upper('hello')
```

- 두 방식은 같다.
- 1: 단축형 호출, 객체지향 방식의 매서드를 호출하는 표현
- self가 없으면 에러가 발생하는 이유

<br>
<br>
<br>

```python
class MyClass:
    def __init__(self): # 1
        self.count = 0 # 2

    def increment(self):
        self.count += 1 #3
```

- \_\_**init**\_\_도 인스턴스 함수에 해당함 self 안받으면 동작 x
- 2: 인스턴스 변수 초기화
- 3: 인스턴스 변수를 1 증가 시킴
  <br>
  <br>

### 클래스 메서드

- `@classmethod` 데코레이터를 사용해 정의
- 클래스가 호출하는 메서드
- 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행
- 호출 시 첫 번째 인자로 해당 메서드를 호출하는 클래스를 전달
  - @classmethod 데코레이터가 붙은 클래스 메서드는 첫 번째 인자로 항상 클래스를 자동으로 받는 것
- 클래스를 인자로 받아 클래스 속성을 변경/읽는 데 사용

### 스태틱 메서드

- `@staticmethod` 데코레이터를 사용해 정의
- 클래스, 인스턴스와 상관없이 독립적으로 동작
  - 호출 시 자동으로 전달 받는 인자가 없음
    - self, cls 안 받음
- 인스턴스/클래스 속성에 직접 접근하지 않는, 도우미 함수와 비슷한 역할

### 매직 메서드

- \_\_(double underscore)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드
- 인스턴스 메서드
- 특정 상황에서 자동으로 호출
- \_\_str\_\_(self): 내장함수 print에 의해 호출되어 객체 출력을 문자열 표현으로 변경

### 데코레이터

- 함수의 일종. 함수를 인자로 받는다.
- 다른 함수의 코드(원본)를 유지한 채로 수정, 확장하기 위해 사용하는 함수
- 데코레이터 아래에 선언된 함수가 데코레이터의 인자가 됨
